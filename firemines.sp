/*
 *  vim: set ai et ts=4 sw=4 :

    TF2 Firemines - SourceMod Plugin
    Copyright (C) 2008  Marc Hörsken

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; if not, write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

*/

/* Plugin Template generated by Pawn Studio */

#pragma semicolon 1

#include <sourcemod>
#include <sdktools>
#include <tf2>
#include <tf2_stocks>
#include <tf2_player>
#include <entlimit>

#define PL_VERSION "1.1.0"
#define SOUND_A "weapons/smg_clip_out.wav"
#define SOUND_B "sourcecraft/tvumin01.wav" // "items/spawn_item.wav"
#define SOUND_C "sourcecraft/tvumin00.wav" // "ui/hint.wav"
#define SOUND_E "common/wpn_denyselect.wav"

#define MODEL "models/props_2fort/groundlight001.mdl"

enum DropType {OnDeath, WithFlameThrower, OnCommand};

static String:ClassNames[TFClassType][] = {"", "Scout", "Sniper", "Soldier", "Demoman", "Medic", "Heavy Guy", "Pyro", "Spy", "Engineer" };

public Plugin:myinfo = 
{
    name = "TF2 Firemines",
    author = "Hunter",
    description = "Allows pyros to drop firemines on death or with secondary Flamethrower fire.",
    version = PL_VERSION,
    url = "http://www.sourceplugins.de/"
}

new bool:g_IsRunning = true;
new Float:g_Position[MAXPLAYERS+1][3];
new g_Ammo[MAXPLAYERS+1];
new g_FireminesTime[2048];
new g_FireminesOwner[2048];
new Float:g_FireminesPos[2048][3];
new g_FilteredEntity = -1;
new g_FiremineModelIndex;
new bool:g_IgniteAvailable = false;
new Handle:g_IsFireminesOn = INVALID_HANDLE;
new Handle:g_FireminesAmmo = INVALID_HANDLE;
new Handle:g_FireminesType = INVALID_HANDLE;
new Handle:g_FireminesDamage = INVALID_HANDLE;
new Handle:g_FireminesRadius = INVALID_HANDLE;
new Handle:g_FireminesKeep = INVALID_HANDLE;
new Handle:g_FireminesLimit = INVALID_HANDLE;
new Handle:g_FriendlyFire = INVALID_HANDLE;

new bool:g_NativeControl = false;
new g_Limit[MAXPLAYERS+1];    // how many mines player allowed
new g_Remaining[MAXPLAYERS+1];  // how many mines player has this spawn

public bool:AskPluginLoad(Handle:myself,bool:late,String:error[],err_max)
{
    MarkNativeAsOptional("TF2_IgnitePlayer"); // To work with SM 1.0 builds

    // Register Natives
    CreateNative("ControlMines",Native_ControlMines);
    CreateNative("GiveMine",Native_GiveMine);
    CreateNative("AddMine",Native_AddMine);
    CreateNative("SubMine",Native_SubMine);
    CreateNative("HasMine",Native_HasMine);
    CreateNative("SetMine",Native_SetMine);
    RegPluginLibrary("firemines");
    return true;
}

public OnPluginStart()
{
    decl String:ver[10];
    new Handle:smver = FindConVar("sourcemod_version");
    GetConVarString(smver, ver, sizeof(ver));
    g_IgniteAvailable = (strncmp(ver, "1.1", 3) == 0);
    CloseHandle(smver);

    LoadTranslations("common.phrases");
    LoadTranslations("firemines.phrases");

    CreateConVar("sm_tf_firemines", PL_VERSION, "Firemines", FCVAR_PLUGIN|FCVAR_SPONLY|FCVAR_REPLICATED|FCVAR_NOTIFY);
    g_IsFireminesOn = CreateConVar("sm_firemines","3","Enable/Disable firemines (0 = disabled | 1 = on death | 2 = on command | 3 = on death and command)");
    g_FireminesAmmo = CreateConVar("sm_firemines_ammo","100","Ammo required for Firemines");
    g_FireminesType = CreateConVar("sm_firemines_type","1","Explosion type of Firemines (0 = normal explosion | 1 = fire explosion)");
    g_FireminesDamage = CreateConVar("sm_firemines_damage","80","Explosion damage of Firemines");
    g_FireminesRadius = CreateConVar("sm_firemines_radius","150","Explosion radius of Firemines");
    g_FireminesKeep = CreateConVar("sm_firemines_keep","180","Time to keep Firemines on map. (0 = off | >0 = seconds)");
    g_FireminesLimit = CreateConVar("sm_firemines_limit", "-1", "Number of firemines allowed per life (-1 = unlimited)");
    g_FriendlyFire = FindConVar("mp_friendlyfire");

    HookConVarChange(g_IsFireminesOn, ConVarChange_IsFireminesOn);
    HookConVarChange(g_FireminesAmmo, ConVarChange_FireminesAmmo);
    HookConVarChange(g_FireminesDamage, ConVarChange_FireminesExplosion);
    HookConVarChange(g_FireminesRadius, ConVarChange_FireminesExplosion);
    HookConVarChange(g_FireminesKeep, ConVarChange_FireminesKeep);
    HookEvent("player_spawn", Event_PlayerSpawn);
    HookEvent("player_death", Event_PlayerDeath);
    HookEvent("teamplay_round_active", Event_RoundStart);
    HookEntityOutput("prop_physics", "OnHealthChanged", EntityOutput:Entity_OnHealthChanged);
    RegConsoleCmd("sm_mine", Command_Firemine);

    CreateTimer(1.0, Timer_Caching, _, TIMER_REPEAT);
}

public OnMapStart()
{
    decl String:file[PLATFORM_MAX_PATH+1];

    PrecacheModel(MODEL, true);
    PrecacheSound(SOUND_A, true);
    PrecacheSound(SOUND_E, true);

    PrecacheSound(SOUND_B, true);
    Format(file, PLATFORM_MAX_PATH, "sound/%s", SOUND_B);
    AddFileToDownloadsTable(file);

    PrecacheSound(SOUND_C, true);
    Format(file, PLATFORM_MAX_PATH, "sound/%s", SOUND_C);
    AddFileToDownloadsTable(file);

    g_IsRunning = true;
}

// When a new client is put in the server we reset their mines count
public bool:OnClientConnect(client, String:rejectmsg[], maxlen)
{
    if(client && !IsFakeClient(client))
    {
        g_Remaining[client] = g_Limit[client] = g_NativeControl ? 0 : GetConVarInt(g_FireminesLimit);
    }
    return true;
}

public OnClientDisconnect(client)
{
    g_Ammo[client] = 0;
    g_Position[client] = NULL_VECTOR;
}

public ConVarChange_IsFireminesOn(Handle:convar, const String:oldValue[], const String:newValue[])
{
    if (StringToInt(newValue) > 0)
    {
        g_IsRunning = true;
        PrintToChatAll("[SM] %t", "Enabled Firemines");
    }
    else
    {
        g_IsRunning = false;
        PrintToChatAll("[SM] %t", "Disabled Firemines");
    }
}

public ConVarChange_FireminesAmmo(Handle:convar, const String:oldValue[], const String:newValue[])
{
    if (StringToInt(newValue) < 0 || StringToInt(newValue) > 200)
    {
        SetConVarInt(convar, StringToInt(oldValue), false, false);
    }
}

public ConVarChange_FireminesExplosion(Handle:convar, const String:oldValue[], const String:newValue[])
{
    if (StringToFloat(newValue) < 0 || StringToFloat(newValue) > 1000)
    {
        SetConVarFloat(convar, StringToFloat(oldValue), false, false);
    }
}

public ConVarChange_FireminesKeep(Handle:convar, const String:oldValue[], const String:newValue[])
{
    if (StringToInt(newValue) < 0 || StringToInt(newValue) > 600)
    {
        SetConVarInt(convar, StringToInt(oldValue), false, false);
    }
}

public Action:Command_Firemine(client, args)
{
    if(!g_IsRunning)
        return Plugin_Handled;
    new FireminesOn = GetConVarInt(g_IsFireminesOn);
    if (FireminesOn < 2)
        return Plugin_Handled;

    new DropType:cmd;
    if (g_NativeControl)
        cmd = OnCommand;
    else
    {
        new TFClassType:class = TF2_GetPlayerClass(client);
        if (class != TFClass_Pyro)
            return Plugin_Handled;

        new String:classname[64];
        GetCurrentWeaponClass(client, classname, 64);
        if(!StrEqual(classname, "CTFFlameThrower"))
            return Plugin_Handled;

        cmd = WithFlameThrower;
    }

    TF_DropFiremine(client, cmd);

    return Plugin_Handled;
}

public Action:Timer_Caching(Handle:timer)
{
    new maxclients = GetMaxClients();
    for (new i = 1; i <= maxclients; i++)
    {
        if (IsClientInGame(i) &&
            (g_NativeControl ? g_Limit[i] != 0 : TF2_GetPlayerClass(i) == TFClass_Pyro))
        {
            g_Ammo[i] = TF2_GetAmmoAmount(i);
            GetClientAbsOrigin(i, g_Position[i]);
        }
    }

    new FireminesKeep = GetConVarInt(g_FireminesKeep);
    if (FireminesKeep > 0)
    {
        new time = GetTime() - FireminesKeep;
        for (new c = 0; c < 2048; c++)
        {
            if (g_FireminesTime[c] != 0 && g_FireminesTime[c] < time)
            {
                g_FireminesTime[c] = 0;
                g_FireminesOwner[c] = 0;
                g_FireminesPos[c] = NULL_VECTOR;
                if (IsValidEntity(c))
                {
                    new String:classname[64];
                    GetEntityNetClass(c, classname, 64);
                    if(StrEqual(classname, "CPhysicsProp"))
                    {
                        // Make sure it's a Firemine
                        if (GetEntProp(c,Prop_Send,"m_nModelIndex") == g_FiremineModelIndex)
                        {
                            EmitSoundToAll(SOUND_C, c, _, _, _, 0.75);
                            RemoveEdict(c);
                        }
                    }
                }
            }
        }
    }
}

public Action:Event_RoundStart(Handle:event, const String:name[], bool:dontBroadcast)
{
    if(g_NativeControl)
        return;

    new FireminesOn = GetConVarInt(g_IsFireminesOn);
    switch (FireminesOn)
    {
        case 1:
            PrintToChatAll("[SM] %t", "OnDeath Firemines");
        case 2:
            PrintToChatAll("[SM] %t", "OnCommand Firemines");
        case 3:
            PrintToChatAll("[SM] %t", "OnDeathAndCommand Firemines");
    }
}

public Action:Event_PlayerSpawn(Handle:event, const String:name[], bool:dontBroadcast)
{
    new client = GetClientOfUserId(GetEventInt(event, "userid"));

    if (g_NativeControl)
        g_Remaining[client] = g_Limit[client];
    else
        g_Remaining[client] = g_Limit[client] = GetConVarInt(g_FireminesLimit);

    return Plugin_Continue;
}

public Action:Event_PlayerDeath(Handle:event, const String:name[], bool:dontBroadcast)
{
    if(!g_IsRunning)
        return;
    new FireminesOn = GetConVarInt(g_IsFireminesOn);
    if (FireminesOn < 1 || FireminesOn == 2)
        return;

    new client = GetClientOfUserId(GetEventInt(event, "userid"));
    if (g_NativeControl)
    {
        if (g_Remaining[client] == 0 || !IsClientInGame(client))
            return;
    }
    else
    {
        if (!IsClientInGame(client) ||
            TF2_GetPlayerClass(client) != TFClass_Pyro)
            return;

        new TFClassType:class = TF2_GetPlayerClass(client);	
        if (class != TFClass_Pyro)
            return;
    }

    TF_DropFiremine(client, OnDeath);
}

public Entity_OnHealthChanged(const String:output[], caller, activator, Float:delay)
{
    new maxclients = GetMaxClients();
    if (g_FireminesTime[caller] > 0 && IsClientInGame(g_FireminesOwner[caller]) && activator <= maxclients && IsClientInGame(activator))
    {
        if (GetConVarInt(g_FireminesType))
        {
            new Float:PlayerPosition[3];
            new Float:maxdistance = GetConVarFloat(g_FireminesRadius);
            for (new i = 1; i <= maxclients; i++)
            {
                if (IsClientInGame(i))
                {
                    GetClientAbsOrigin(i, PlayerPosition);
                    if (GetVectorDistance(PlayerPosition, g_FireminesPos[caller]) <= maxdistance)
                    {
                        new team = 0;
                        if (!GetConVarInt(g_FriendlyFire))
                            team = GetClientTeam(g_FireminesOwner[caller]);

                        if ((team != GetClientTeam(i)) || (i == g_FireminesOwner[caller]))
                        {
                            if (g_IgniteAvailable)
                                TF2_IgnitePlayer(i, g_FireminesOwner[caller]);
                            else
                                IgniteEntity(i, 5.0);
                        }
                    }
                }
            }
        }

        SetEntPropEnt(caller, Prop_Data, "m_hLastAttacker", g_FireminesOwner[caller]);
        SetEntPropEnt(caller, Prop_Data, "m_hPhysicsAttacker", g_FireminesOwner[caller]);

        new team = 0;
        if (!GetConVarInt(g_FriendlyFire))
            team = GetClientTeam(g_FireminesOwner[caller]);
        if ((team != GetClientTeam(activator)) || (activator == g_FireminesOwner[caller]))
            AcceptEntityInput(caller, "Break", activator, g_FireminesOwner[caller]);

        g_FireminesTime[caller] = 0;
        g_FireminesOwner[caller] = 0;
        g_FireminesPos[caller] = NULL_VECTOR;
    }
}

public bool:FiremineTraceFilter(ent, contentMask)
{
    return (ent != g_FilteredEntity);
}

stock TF_SpawnFiremine(client, String:name[], DropType:cmd)
{
    new Float:PlayerPosition[3];
    if (cmd != OnDeath)
        GetClientAbsOrigin(client, PlayerPosition);
    else
        PlayerPosition = g_Position[client];

    if (PlayerPosition[0] != 0.0 && PlayerPosition[1] != 0.0 && PlayerPosition[2] != 0.0 && IsEntLimitReached() == false)
    {
        PlayerPosition[2] += 4;
        g_FilteredEntity = client;
        if (cmd != OnDeath)
        {
            new Float:PlayerPosEx[3], Float:PlayerAngle[3], Float:PlayerPosAway[3];
            GetClientEyeAngles(client, PlayerAngle);
            PlayerPosEx[0] = Cosine((PlayerAngle[1]/180)*FLOAT_PI);
            PlayerPosEx[1] = Sine((PlayerAngle[1]/180)*FLOAT_PI);
            PlayerPosEx[2] = 0.0;
            ScaleVector(PlayerPosEx, 75.0);
            AddVectors(PlayerPosition, PlayerPosEx, PlayerPosAway);

            new Handle:TraceEx = TR_TraceRayFilterEx(PlayerPosition, PlayerPosAway, MASK_SOLID, RayType_EndPoint, FiremineTraceFilter);
            TR_GetEndPosition(PlayerPosition, TraceEx);
            CloseHandle(TraceEx);
        }

        new Float:Direction[3];
        Direction[0] = PlayerPosition[0];
        Direction[1] = PlayerPosition[1];
        Direction[2] = PlayerPosition[2]-1024;
        new Handle:Trace = TR_TraceRayFilterEx(PlayerPosition, Direction, MASK_SOLID, RayType_EndPoint, FiremineTraceFilter);

        new Float:MinePos[3];
        TR_GetEndPosition(MinePos, Trace);
        CloseHandle(Trace);
        MinePos[2] += 1;

        new Firemine = CreateEntityByName(name);
        SetEntityModel(Firemine, MODEL);
        DispatchKeyValue(Firemine, "StartDisabled", "false");
        if (DispatchSpawn(Firemine))
        {
            new String:targetname[32];
            new team = GetClientTeam(client);

            Format(targetname, 32, "firemine_%d", Firemine);
            TeleportEntity(Firemine, MinePos, NULL_VECTOR, NULL_VECTOR);
            SetEntProp(Firemine, Prop_Send, "m_iTeamNum", team, 4);
            SetEntProp(Firemine, Prop_Data, "m_usSolidFlags", 152);
            SetEntProp(Firemine, Prop_Data, "m_nSolidType", 6);
            SetEntProp(Firemine, Prop_Data, "m_takedamage", 3);
            SetEntPropEnt(Firemine, Prop_Data, "m_hLastAttacker", client);
            SetEntityMoveType(Firemine, MOVETYPE_NONE);
            DispatchKeyValue(Firemine, "targetname", targetname);
            DispatchKeyValue(Firemine, "spawnflags", "152");
            DispatchKeyValue(Firemine, "physdamagescale", "0");
            //DispatchKeyValue(Firemine, "OnHealthChanged", "!self,Break,,0,-1");
            DispatchKeyValue(Firemine, "OnBreak", "!self,Kill,,0,-1");
            DispatchKeyValueFloat(Firemine, "ExplodeDamage", GetConVarFloat(g_FireminesDamage));
            DispatchKeyValueFloat(Firemine, "ExplodeRadius", GetConVarFloat(g_FireminesRadius));
            EmitSoundToAll(SOUND_B, Firemine, _, _, _, 0.75);
            g_FiremineModelIndex = GetEntProp(Firemine,Prop_Send,"m_nModelIndex");
            g_FireminesTime[Firemine] = GetTime();
            g_FireminesOwner[Firemine] = client;
            g_FireminesPos[Firemine] = MinePos;
        }
    }
}

stock bool:TF_DropFiremine(client, DropType:cmd)
{
    if (g_Remaining[client] <= 0 && g_Limit[client] >= 0)
    {
        PrintHintText(client, "You do not have any mines.");
        EmitSoundToClient(client, SOUND_A, _, _, _, _, 0.75);
        return false;
    }

    if (cmd != WithFlameThrower)
    {
        if (TF2_GetPlayerClass(client) == TFClass_Spy)
        {
            if (TF2_IsPlayerCloaked(client))
            {
                EmitSoundToClient(client, SOUND_E);
                return false;
            }
            else
                TF2_RemovePlayerDisguise(client);
        }
    }

    new ammo;
    if (cmd != OnDeath)
        ammo = TF2_GetAmmoAmount(client);
    else
        ammo = g_Ammo[client];

    new FireminesAmmo = GetConVarInt(g_FireminesAmmo);
    switch (TF2_GetPlayerClass(client))
    {
        case TFClass_Medic:     FireminesAmmo = RoundToNearest(float(FireminesAmmo) / 1.33);
        case TFClass_Scout:     FireminesAmmo = RoundToNearest(float(FireminesAmmo) / 6.5);
        case TFClass_Engineer:  FireminesAmmo = RoundToNearest(float(FireminesAmmo) / 6.5);
        case TFClass_Soldier:   FireminesAmmo = RoundToNearest(float(FireminesAmmo) / 12.5);
        case TFClass_DemoMan:   FireminesAmmo = RoundToNearest(float(FireminesAmmo) / 12.5);
        case TFClass_Sniper:    FireminesAmmo /= 10;
        case TFClass_Spy:       FireminesAmmo /= 10;
    }
    LogMessage("class=%s,ammo=%d,amount=%d",ClassNames[TF2_GetPlayerClass(client)],ammo, FireminesAmmo);
    if (ammo >= FireminesAmmo)
    {
        if (cmd != OnDeath)
        {
            ammo -= FireminesAmmo;
            TF2_SetAmmoAmount(client, ammo);
            g_Ammo[client] = ammo;

            // update client's inventory
            if (g_Remaining[client] > 0)
                g_Remaining[client]--;
        }

        TF_SpawnFiremine(client, "prop_physics_override", cmd);

        return true;
    }
    if (cmd != OnDeath)
    {
        EmitSoundToClient(client, SOUND_A, _, _, _, _, 0.75);
        //	PrintCenterText(client, "Not enough Ammo!");
    }
    return false;
}


public Native_ControlMines(Handle:plugin,numParams)
{
    if (numParams == 0)
        g_NativeControl = true;
    else if(numParams == 1)
        g_NativeControl = GetNativeCell(1);
}

public Native_GiveMine(Handle:plugin,numParams)
{
    if (numParams >= 1 && numParams <= 2)
    {
        new client = GetNativeCell(1);
        g_Remaining[client] = g_Limit[client] = (numParams >= 2) ? GetNativeCell(2) : GetConVarInt(g_FireminesLimit);
    }
}

public Native_AddMine(Handle:plugin,numParams)
{
    if (numParams >= 1 && numParams <= 2)
    {
        new client = GetNativeCell(1);
        if (g_Limit[client] >= 0)
        {
            new num = (numParams >= 2) ? GetNativeCell(2) : 1;
            g_Remaining[client] += num;
            g_Limit[client] += num;
        }
    }
}

public Native_SubMine(Handle:plugin,numParams)
{
    if (numParams >= 1 && numParams <= 2)
    {
        new client = GetNativeCell(1);
        if (g_Limit[client] >= 0)
        {
            new num = (numParams >= 2) ? GetNativeCell(2) : 1;

            g_Remaining[client] -= num;
            if (g_Remaining[client] < 0)
                g_Remaining[client] = 0;

            g_Limit[client] -= num;
            if (g_Limit[client] < 0)
                g_Limit[client] = 0;
        }
    }
}

public Native_HasMine(Handle:plugin,numParams)
{
    if (numParams >= 1 && numParams <= 2)
    {
        new client = GetNativeCell(1);
        return ((numParams >= 2) && GetNativeCell(2)) ? g_Limit[client] : g_Remaining[client];
    }
    else
        return -1;
}

public Native_SetMine(Handle:plugin,numParams)
{
    if (numParams == 1)
        TF_DropFiremine(GetNativeCell(1), OnCommand);
}
